---
title: Unity 脚本生命周期函数详解
date: 2025-12-25 11:59:28
tags:
- Unity
- C#
categories:
- 游戏开发
---

理解 MonoBehaviour 的生命周期是 Unity 开发的核心基础。下面这张流程图直观地展示了各个关键函数的执行顺序，你可以将其作为阅读后续详细说明的路线图。
{% mermaid %}

flowchart TD
    A[脚本实例被加载] --> B[Reset<br>（编辑模式下）]
    B --> C[Awake<br>（仅调用一次）]
    C --> D{对象是否激活?}
    D -- 是 --> E[OnEnable]
    D -- 否 --> F[等待激活]
    E --> G[Start<br>（仅调用一次）]
    G --> H[[游戏循环开始]]
    H --> I[FixedUpdate<br>（物理帧）]
    I --> J[Update<br>（游戏逻辑帧）]
    J --> K[LateUpdate<br>（后续逻辑帧）]
    K --> L[OnGUI<br>（渲染与GUI事件）]
    L --> M{循环继续?}
    M -- 是 --> I
    M -- 否 --> N[游戏循环结束]
    N --> O[OnDisable]
    O --> P[OnDestroy]
{% endmermaid %}


下面，我们按照这个顺序，详细解读每个阶段的重要函数。

### 💡 初始化阶段

这个阶段的函数在脚本一生中通常只执行一次，用于初始设置。

*   **Reset()**: 仅在 Unity 编辑器中生效。当你首次将脚本挂载到游戏对象，或在检视面板点击 `Reset` 按钮时调用，常用于设置默认值。
*   **Awake()**: 无论脚本是否启用，只要其挂载的游戏对象处于激活状态，就会在脚本实例被加载时**立刻调用一次**。它最适合用于**初始化变量**或建立脚本间的引用。
*   **OnEnable()**: 当脚本组件或游戏对象**变为激活状态时**被调用。不同于 `Awake`，它可以在脚本的生命周期内**多次触发**（例如，脚本被禁用再重新启用时）。
*   **Start()**: 在脚本**启用状态下**，于**第一帧更新之前**（即第一次 `Update` 调用前）**仅执行一次**。它通常在 `Awake` 之后执行，适用于需要确保其他脚本已完成初始化的设置。

### 🔁 循环执行阶段

这是游戏逻辑的核心，包含每帧或每个固定时间间隔执行的函数。

*   **FixedUpdate()**: 在**每个固定的物理时间步长**（默认0.02秒，可在 `Project Settings > Time` 中调整）被调用。它的调用频率与帧率无关，非常稳定，因此是处理**物理计算**（如对刚体施加力）的理想位置。
*   **Update()**: 最常用的函数，**每帧调用一次**。但其时间间隔不固定，取决于游戏帧率。所有主要的**游戏逻辑**，如输入处理、非物理性的移动等，都应放在这里。为了避免不同性能设备上速度不一致，移动操作通常要乘以 `Time.deltaTime`。
*   **LateUpdate()**: 在同一帧内，**所有 `Update` 函数执行完毕后调用**。常用于处理需要基于当前帧最终结果的操作，最典型的例子是**相机跟随**，这样可以确保相机的位置调整是在目标物体移动完成之后进行的。

### 🎨 渲染与交互阶段

这个阶段处理与图形用户界面和用户交互相关的事件。

*   **OnGUI()**: 用于绘制古老的 IMGUI 系统。它在一帧内可能被调用多次（每次处理GUI事件时），现在更主流的UI方案是 UGUI 和 UI Toolkit。
*   **OnMouseXXX()** (如 `OnMouseDown`, `OnMouseEnter`): 当鼠标与挂载了碰撞体的游戏对象交互时触发的一系列函数。

### 🧹 结束阶段

在脚本或对象被禁用、销毁时调用，用于资源清理。

*   **OnDisable()**: 当脚本或游戏对象**变为非激活状态时**调用。也适用于对象被销毁时的清理工作，可以在此处取消所有 `Invoke` 调用或协程。
*   **OnDestroy()**: 当脚本实例或游戏对象**被销毁时**（例如通过 `Destroy()` 方法或切换场景）调用，用于执行最终的清理工作。
*   **OnApplicationQuit()**: 在游戏应用程序**退出之前**被调用。

### 实践建议与总结

为了更深入地理解，你可以创建一个测试脚本，将所有生命周期函数都实现，并在每个函数内使用 `Debug.Log` 打印日志，然后在游戏中观察控制台的输出顺序。

下面这个表格帮你快速回顾最主要的生命周期函数及其特点：

| 函数 | 执行时机 | 关键特点 |
| :--- | :--- | :--- |
| **`Awake`** | 脚本实例加载时 | 仅一次，与是否激活无关，用于初始化 |
| **`Start`** | 首次更新前，脚本启用时 | 仅一次，在`Awake`之后，用于依赖其他脚本的初始化 |
| **`FixedUpdate`** | 每个固定物理时间步长，是项目设定的时间频率 | 频率稳定，用于物理计算 |
| **`Update`** | 每帧 | 频率不固定，用于核心游戏逻辑，和设备有关，牛逼的电脑帧率就高一些 |

| **`LateUpdate`** | 每帧，所有`Update`之后 | 用于基于当前帧最终结果的操作（如相机跟随） |
| **`OnDisable`** | 对象变为非激活或销毁前 | 用于清理资源、停止协程等 |
| **`OnDestroy`** | 对象销毁时 | 用于最终清理 |

PS： 如果在项目中不需要生命周期函数，建议不要添加它们，以免增加不必要的开销。
因为Unity 是通过反射机制加载这些函数，反射本身在底层的开销挺大，建议不需要的情况下，不要添加所有的生命周期函数

